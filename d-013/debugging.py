"""
-=< 100 Days of Python >=-
-=[ Day 013 ]=-
"""
"""
In today's lessons we'll learn a bit about 'Debugging':
(i.e. the process of removing bugs from your code)
- How to understand error messages
- How to approach debugging
- Finding and fixing errors in our code
- Best practices, extra tools and useful tips
"""
"""
L.94 - Describe the Problem

The first step towards debugging a problem is to make sure that you actually
understand what it is the code is *meant* to be doing.
- i.e. do you understand the problem the code is trying to solve?

Let's look at the following example:
"""
for i in range(1, 20):
    if i == 20:
        print("You got it!")
"""
As you can probably see, at some point in the loop, it is meant to print a
line out to the console. However, when we actually run this code, nothing
get's printed out ... So what is going wrong?

Let's break this down and describe the problem:

1. What is the loop doing?
- It is looping through a range of numbers from 1 up to (not including) 20.

2. When is it meant to print "You got it!"?
- When the loop variable 'i' is equal to 20.

3. What are your assumptions about the value of 'i'?
- 'i' is equal to the value generated by the range function each iteration.
However, due to the range function's parameters (i.e. lower bound is
inclusive, upper bound is exclusive) 'i' will never be equal to 20, since
range will stop at 19 (excluding the upper bound)!


So, we can fix the code in one of two ways:
- 1. Change the test condition of the IF statement to equal the last number
that will actually be generated by the range function (i.e. 19).
- 2. Change the value of the second parameter in the range function so that
the last value it generates is 20, thereby satisfying the conditional test.

In practice, how we decide to fix this code may depend on the specific goals,
requirements or other qualifying factors of the larger program. However for
the purposes of this example let's assume that the conditional test has a
purpose, so we will change the upper bound of range to ensure that '20' is
generated:
"""
for i in range(1, 21):
    if i == 20:
        print("You got it!")

"""
L.95 - Reproduce the Bug

The next step to think about is how to go about reproducing the bug.

Programs typically have many variable factors which can change each time we
run them, due to different inputs or starting conditions etc. As such, it is
entirely possible that we could encounter a bug on one run through a program,
but not the next time we run it.

These kinds of intermittent bugs can be the hardest to chase down, and it can
be very confusing when a program works sometimes but not others. In these
cases working out exactly what is causing the bug can be a real challenge. So
having a planned, systematic and logical approach will help you to narrow
things down and identify the cause in an efficient manner.

We'll start with the following code:
"""
from random import randint  # nopep8
dice_images = ["①", "②", "③", "④", "⑤", "⑥"]
dice_num = randint(1, 6)
# $save
print(dice_images[dice_num] + "\n")
"""
When we run this code it mostly works, but occasionally we will get an error.
So, to debug this we need to figure out exactly when that error occurs
- i.e. what specific conditions cause the error.

We can see that the program is using 'randint', from the random module, to
generate a random whole number between 1 and 6. In the case of this example
that random number is really the only variable factor, so we know that it
must be one of the possible generated values which is causing the error.

We can test this theory, and help to identify the problem, by using
hard-coded values in place of the random numbers, to test each value in turn.
"""
# For the purpose of this example we can use a loop, as this will allow us to
# demonstrate all the possible values consecutively, one after another.
# Remembering to increment the upper-bound parameter so that '6' is included!
# $end
for n in range(1, 7):
    print(f"Testing number: {n}")
    print(dice_images[n])
print("\n")
"""
The output from this loop shows us that the value causing the error is '6'.
- The error message says: "list index out of range"

So, we know that the list object ('dice_images') does not have '6' in it's
index values.

However, the output also shows us that when we test the value '1' we get the
dice number '②' (rather than '①') ... why is that?

Well, if we remember (or look up) how indexing with Lists work, we realise
that the index starts at 0 (zero), for the item in the first position.

We know that the values generated by 'randint' will fall between 1 and 6
(inclusively), but we now know that the values we need for the list index
range from 0 to 5.
"""
# Let's show how the list's index values are associated with the items:
for index, item in enumerate(dice_images):
    print(f"List index '{index}' = {item}")
"""
With all of this information now in hand, we are able to update the code so
that we no longer get an error:
"""
# If we update the range values used with randint we no longer get the error!
dice_num = randint(0, 5)
print("\nFixed random dice roll:")
print(dice_images[dice_num] + "\n")

"""
L.96 - Play Computer and Evaluate Each Line

Another useful skill when it comes to debugging, and in fact programming in
general, is learning to think (or at least pretending to think) like a
computer. This can help with both planning and implementing your code,
anticipating how the computer will interpret it, as well as determining what
went wrong when an error inevitably does occur.

For this exercise, take a look at the code below:
"""
year = int(input("What's your year of birth? "))
if 1980 < year < 1994:
    print("You're a Millennial.")
elif year > 1994:
    print("You're a Gen-Z!")
"""
Play around and test the code, but notice what happens when you put in the
year "1994" ... absolutely nothing, you get no output -- So that's the bug!

Now we need to try to "think like a computer", run through the code line by
line, think about the logic and what it will evaluate to. Once we've
identified the error in the logic we can go ahead and fix the bug.

The problem is that 1994 is not less than (1st test) or greater than (2nd
test) 1994, it is exactly equal to it. So, currently there is no test
condition that captures the value 1994. -- I suppose the question now
becomes, is someone born in 1994 a 'Millennial' or a 'Gen-Z'?

Whichever your preference we can fix the program by updating one of the test
conditions to include this value, using either the "less-than or equal to" or
"greater-than or equal to" operator in the appropriate statement...
"""
if 1980 < year <= 1994:
    print("You're a Millennial.")
if year > 1994:
    print("You're a Gen-Z!")
# 'Gen-Z' is now effectively anyone born in or after 1995
"""
...of course we could have changed the comparison value instead of the
operator, but the point was to work out the error in the logic as it was
written -- Thinking like a Computer! =D
"""

"""
L.97 - Fixing Errors (and Watching for Red Underlines)

These next tips should be obvious...

If the editor or console is giving you an error, fix it before continuing!

Most code editors will attempt to predict potential errors, typically marking
them with a wavy red underline (like spelling errors in a Word Processor).
These are easier to deal with since you'll be able to see the line, or part
of code, which is broken. They will also often provide extra information in
a pop-up tooltip, when you hover over the highlighted error.

However, not all errors are able to be predicted by editors so it's is always
worth running your code from time to time to test functionality and ensure
things are working as expected. Remember that some errors may only occur with
certain (often unexpected) input values. For example, consider the code below:
"""
age = int(input("How old are you? "))
"""
This code may seem simple enough, but what happens if you enter the *word*
for a number, instead of numerical characters -- e.g. "fifteen", not 15!

Well, the 'int' conversion function can only handle strings of numerical
characters, so the above example would cause the following error:
- "ValueError: invalid literal for int() with base 10: 'fifteen'"

The easiest way to fix this error, or prevent it from happening, is to tell
the user to only enter numerical characters. We should probably also try to
enforce this, with some kind or check or validation in our code, to ensure
that we only pass a valid string to the conversion function. This process is
called "input validation". You should always strive to implement some form of
input validation whenever asking for input from a user.

One way to approach this is to try to 'catch' the error with code. We can do
this by introducing you to a statement pair/group which we haven't really
seen or used before, the TRY/EXCEPT block. These provide us with the means to
*try* a section of potentially 'dangerous' code, and then provide alternative
code-blocks to run if/when an "exception" (i.e. error) occurs. The statement
permits any number of EXCEPT blocks, allowing us to define different blocks
of code to run for different exceptions, optionally ending with a 'catch-all'
block. -- In effect these behave in a similar way to IF/ELIF/ELSE blocks.

Let's implement this now to address the potential risk for invalid input
from our code before:
"""
try:
    # First we put the risky code in the TRY block
    age = int(input("How old are you? "))
except ValueError:
    # Then we can 'catch' the anticipated error in the EXCEPT block
    # by specifying the type of exception we want to handle
    print("Please limit your input to numerical characters.")
    # We could then prompt for input again...
    age = int(input("How old are you? "))
    # Please realise however that if the user enters invalid input again
    # this will cause another exception here, which is NOT caught/handled!
"""
Now we have our input we can do something with it...
"""
# Like this
if age < 18:
    print("Sorry you can't drive at age {age}")
"""
...but what happens when you run this code though?
-- Yep, not what we wanted/expected!

We forgot to make it an 'f-string', so the variable inside the curly-braces
was not converted to it's value, meaning we just got the literal text "{age}"
instead of the number.

This is to demonstrate that not all errors are immediately identifiable.
Sometimes it takes an unexpected input, or unanticipated situation before a
bug becomes apparent. These can be the most frustrating bugs to solve because
technically the code is valid, and there is no error exception. So in these
cases we can't get any help from the editor, and there is no error message in
the console to help us either. It is down to us to understand what's
happening, read through the code to try to identify the problem, and fix it.
"""
if age < 18:
    print(f"Sorry you can't drive at age {age}")
    # We fixed this now by making it an f-string!
"""
If we were new to programming and/or Python though, and didn't know about
f-strings, then this would've been a very difficult issue to debug!

This is where experience pays off. So learning, increasing your knowledge and
understanding of Python, and programming in general, as well as fixing more
bugs and errors as you get them, will all add up to help you become, not just
a better programmer, but better at debugging too.

So test your code, test other people's code, play around with exercises,
change variables and break code, just to practice fixing it. Maybe go online
and help other people out by answering questions on Stack Overflow, Discord
channels and Reddit sub-groups. All of this will help to hone your debugging
skills, making it easier for you to debug your own code down the line, as
well as make you a better programmer overall. -- Good Luck!!
"""

"""
L.98 - Squash Bugs with a print() Statement

When it comes to debugging, the 'print()' function isn't just a programmer's
friend, it's our best friend! It is the thing you will find yourself using
the most, both while programming (in general) and especially when debugging.

So let's jump in to a piece of code, that may or may not need some debugging
detective work to figure out what is going wrong...

Here is a little program which calculates the number of words in a book.
First we initialise the counter to zero, then we ask for the number of pages
in the book, and the number of words per page. It then multiplies these
numbers together to get the total number of words, which it then prints out.
"""
# pylint: disable=expression-not-assigned
words_per_page = 0
pages = int(input("Number of pages: "))
words_per_page == int(input("Number of words per page: "))
total_words = pages * words_per_page
print(total_words)
"""
Unfortunately, when we run this program and input some test values (e.g. 50
pages, 250 wpp), the total printed out is 0 (zero) ... but why?

Let's go ahead and use our reliable friend 'print()' to try to figure out
what is going wrong...

We know the formula for the calculation is correct, so let's try checking
what the values we're actually plugging in to that calculation are. We can
print out each variable after we have taken the appropriate input.
"""
words_per_page = 0
pages = int(input("Number of pages: "))
print(f"Pages: {pages}")
words_per_page == int(input("Number of words per page: "))
print(f"Words per page: {words_per_page}")
total_words = pages * words_per_page
print(total_words)
"""
This time when we run the code (with the same test values) we can see that
the value captured for the first variable 'pages' is correct as '50', but
the value for the second variable 'words_per_page' is coming back as '0'
instead of '250'.

So the problem must be something to do with the line that captures the input
for that value. With this knowledge we should be able to find and fix the bug
in our code...

You may have seen it already, or your editor may have highlighted it for you.
In the case of the latter, you should be able to hover over the line in your
editor and see the description for the potential error. Something like...
- Expression "words_per_page ...[edit]" is assigned to nothing
This message informs us that the line is seen by the Python interpreter as
an "expression" (i.e. a comparative evaluation) rather than an *assignment*.

For the rest of us, and those of us with a good eye, you can see that the
line has a double equals-sign ('=='), which we should remember is used in
comparative tests to test if the value on the left is 'equal' to the value
on the right. This is NOT what we wanted to do! What we want is to assign the
value to a variable name, which we know is done using a single equals-sign.

Let's go ahead and fix that now:
"""
words_per_page = 0
pages = int(input("Number of pages: "))
words_per_page = int(input("Number of words per page: "))
total_words = pages * words_per_page
print(f"Pages: {pages}")
print(f"Words per page: {words_per_page}")
print(f"Total number of words: {total_words}")
"""
So there we go!

Bugs like this happen all the time. A simple typo when we accidentally hit
the wrong key, or press a key twice, whilst in a rush to get our code out
from our head and on to the screen. -- Easy enough to fix now that our friend
'print()' has helped us to check our assumptions of the code.
"""

"""
L.99 - Bringing out the BIG Gun: Using a Debugger

The 'print()' function may be our debugging BFF when it comes to helping us
catch relatively simple errors, and when working with smaller sections of
code, by ourselves. However, it becomes a bit cumbersome and inefficient
to use when working on larger, more complex projects. Especially given that
it is not particularly desirable to have 'print()' statements littering our
code all over the place, clogging our console with lines of debugging output,
most of which should probably never be seen by the end-user.

As the scale and complexity of our projects increases, or we find ourselves
collaborating on projects with other programmers, we may need the help of
something a bit more powerful. Something which allows us to interact with,
and analyse, our code in 'real-time' as it is executed, without the need to
add lines of code to our files, just for debugging purposes. This is where
the "Debugger" tool steps in to the ring.

Our starting code for this lesson is a function, called 'mutate', which
takes a List of integer numbers as input, and prints out a different List
at the end.

Inside the function, the output List starts out empty, and a local variable
is initialised to '0' (zero). The function then loops through each number in
the input List, doubling it, then adding a random whole-number between
1 and 3. The result of this is stored in the local variable, and later
appended to the output List. At the end of the function the output List
is printed using the 'print()' statement.
"""
# NOTE since we already imported 'random.randint' above, we'll skip this
# BUT, if we wanted to use it here...
# pylint: disable=reimported
# from random import randint  # nopep8

# Similarly, since we haven't actually created the 'maths' module the video
# refers to we'll skip the import and just re-create the function below...
# import maths  # nopep8


def add(n1, n2):
    """Add two simple numbers together and return the result"""
    return n1 + n2


def mutate(a_list):
    """Modifies the numbers in a given List by doubling the number,
    then adding a random number between 1 and 3;
    Adding the results to a new List before printing the new List"""
    b_list = []
    new_num = 0
    for a_num in a_list:
        new_num = a_num * 2
        new_num += randint(1, 3)
        # new_num = maths.add(new_num, a_num)
        # Replaced above with line using local function instead of module:
        new_num = add(new_num, a_num)
    b_list.append(new_num)
    print(b_list)


mutate([1, 2, 3, 5, 8, 13])
"""
When we run this code however, rather than a List of numbers, we get a single
value output. This is not what we want!

In order to fix this we'e going to use a Python Debugger tool, built-in (or
installable as an extension) to your Programming-IDE (i.e. code editor).
Thankfully these work in pretty much the same way, regardless of your
specific IDE, so a lot of these tips will be similar and reusable across a
range of development environments.

In order to use the Debugging Tool we need to create something called a
"break-point". This is the point at which the execution of the code, at
run-time, will be handed over to the control of the Debugger for us to
interact with.

If you hover your mouse over the line-numbers in the 'gutter', down the side
of your code, you should see a red dot appear next to it. This dot indicates
which line will trigger the break-point. Then, when we click on the dot the
break-point is registered, and the dot stays next to that line to indicate
where the Debugger will kick in.

Once we have a break-point we can run the code in 'debug' mode using the
'Run and Debug' icon (this usually has a little bug symbol on it), or with
the relevant option under the 'Run' tab in the menu-bar.

When you run your code with the debugger you will typically see a console
window appear, as well as a debugging information panel. This displays the
current state of your program as you run through it, including all defined
variables and their values, which are kept updated in real-time.

Effectively, once triggered by a break-point, the debugging tool halts the
normal execution of your code, and then allows you to walk through your code
line-by-line, controlling the progress in a few key ways (represented by the
controls on the 'Debugging Toolbar' that appears). These are typically:

    1.  "Continue": Continues 'normal' execution of the code, processing
        additional lines automatically, without pausing or prompting, until
        another break-point is hit, an error occurs, or the end of the file
        is reached.
        Note: This button may also double-up as a "Pause" function, which
        pauses 'normal' code execution, switching back to code inspection and
        line-by-line execution, as if we'd hit another break-point.
    
    2.  "Step-Over": Runs the current line of code in it's entirety. Execution
        is processed in the background, with no further interaction required
        until the next line is reached -- i.e. it 'steps-over' the specifics
        and complexities of executing that line.
        We use this when we don't really care about *how* the line of code is
        executed (or where that code resides), so long as it *is* processed.
        Execution halts again at the start of the next line.
    
    3.  "Step-Into": Causes the current line of code to be executed
        step-by-step, literally, as it is seen by the Python interpreter.
        Steps which require additional line(s) of code to be processed (e.g.
        due to a function call) are also handled one at a time, in the order
        of execution, using the same debugging controls, such that...
        - 'stepping-over' any additional lines will allow those lines to be
        executed in the background, without following the explicit process.
        - 'stepping-into' any additional lines will follow the explicit
        execution process for each step, which may traverse the code-tree,
        local files, the Python Standard Library, or external modules, in a
        cascade-like manner, eventually traversing back up the cascade as
        each subsequent step completes. Execution is halted by the debug-tool
        at each step, allowing for fine-grained control of the debug process.
        - 'stepping-out' of any additional step allows the rest of the process
        for that step to execute in the background, returning to the code that
        initiated that step at the point where that step is complete. Halting
        execution at the start of the next step, or at the start of the next
        line when no more steps from the initiating line exist.

    4.  "Step-Out": [Where a process has been 'stepped-into'...]
        Any remaining execution for the current process is moved to, and
        completed in, the background. Debugging execution control returns to
        the point in the initiating line of code at which the sub-process is
        complete, and the next step or line is pending.
    
    5.  "Restart": Terminates the current debugging session and restarts the
        debugger for the current file, using the previous debug configuration.
    
    6.  "Stop": Terminates the current debugging session, and closes the
        debug-tool.


Ref: https://code.visualstudio.com/Docs/editor/debugging
        

By far one of the most useful features when using a Debugging Tool, is being
able to see the values for all the different variables, at each step, as you
walk through the code's execution line-by-line.

Code inspection can also be useful, allowing you to follow the step-by-step
execution of code as it passes into different functions, and sub-processes.
Especially when working with multiple files; Or, if you are ever unsure of
where a particular function is coming from, or how it has been implemented.


>> Solution:

Now that you understand how the debugger works, and have set a break-point,
it's time to figure out why our code is returning a single number instead of
a List.

After stepping through the code with the debugger you should have realised
that the only time a value is actually added to the output list is *after*
the entire FOR loop has finished. This is the error, and explains why we 
only get a single value (i.e. the last value processed) in the output.

So, the line which append's the variable "new_num" to the List "b_list" needs
to be placed *inside* the FOR loop, to ensure that each modified number is
added to the List for output -- As shown below:
"""
# pylint: disable=function-redefined


def mutate(a_list):
    """Modifies the numbers in a given List by doubling the number,
    then adding a random number between 1 and 3;
    Adding the results to a new List before printing the new List"""
    b_list = []
    new_num = 0
    for a_num in a_list:
        new_num = a_num * 2
        new_num += randint(1, 3)
        new_num = add(new_num, a_num)
        b_list.append(new_num)
    print(b_list)


mutate([1, 2, 3, 5, 8, 13])
"""
A simple indentation error meant that the append line was outside of the
FOR loop when it needed to be inside it. When we run this code now it
correctly prints out a list of 6 different numbers.
"""

"""
L.100 - Final Debugging Tips

In the past few lessons we've covered the main tips, tricks and tools we can
use to help us debug our programs, because no matter good a programmer we are,
or become, there will always be bugs to find and fix.

To recap quickly, these were:
1. Describe the Problem
2. Reproduce the Bug
3. Play Computer
4. Fix the Errors
5. Print is Your Friend
6. Use a Debugger

The last handful of tips, that come from experience as well as good advice,
are as follows...

7. Take a Break:

Programmers often let themselves get in to the nasty habit of staring blankly
at a screen full of code, banging their head against the proverbial brick
wall, trying to fix their code. We have a strange way of convincing ourselves
that if we stare at a problem for long enough we'll be able to find a
solution. When what we should really do is take a break!

Give your brain a rest and go and make a cup of tea or coffee, go for a
walk, take a nap, or just go to bed, get some sleep, and tackle it again
fresh tomorrow. Sometimes the best thing you can do is get away from your
screen, let your brain switch tasks and think about something else for a
while, then come back to the problem with a fresh, or at least refreshed,
pair of eyes.

8. Ask a Friend:

If you've been struggling with a bug for a while, and you've given yourself
a healthy break away from the problem but you still can't see it or work it
out, then ask a friend for help.

Probably not our trusty friend `print()`, but a real human. Another developer,
a fellow student, people on you favourite Python Discord channel or Reddit
group, or by posting a question on Stack Exchange.

When we've been staring at the same code for so long, going over and over it
time and again, so much so that our brain starts to mentally skip over bits,
a fresh set of eyes on a problem can often see things that we've managed to
give ourselves a mental blind-spot for.

Most developers are overly self-critical, and rarely receive much if any praise
for their efforts, especially from themselves. So don't worry, reaching out to
someone to ask for their help will likely give them a much needed ego boost.
Even if they don't actually find or fix the problem for you, just talking
through the problem with someone can often help to jog your own brain in to
gear, or help to clear those mental blind-spots and give you a sudden moment
of clarity.

9. Run Your Code Often:

By running our code regularly we can test our functionality incrementally, as
we go along, which often makes it easier to find and fix little bugs quickly.
If we wait until we've written a whole bunch of code before we test it, we
could end up with numerous errors and bugs to fix. Not only can this be a bit
overwhelming to tackle all in one go, but it also makes it a lot harder to
work out exactly what is going on with our code.

If you do end up in a situation where you have several bugs and errors, all
happening at the same time, then try to tackle and fix them one at a time.
Test each solution thoroughly to be sure it does what you expect it to,
before moving on to the next. This way you build up confidence in the
reliability of your code as you work through the bugs. This ensures that,
where any section relies on another part of your code (such as a function),
which you've already covered and tested, then you can be sure that *that*
part works as intended, and is not contributing to the current bug.

10. Ask on Stack Overflow:

Stack Overflow is one of the most powerful tools in any developer's tool-belt.
Unfortunately, as a resource and a "Question & Answer" platform, it is one
that is often misunderstood and, if not exactly 'abused', then certainly all
too often misused.

All of the sites on the Stack Exchange network should, first and foremost, be
used to **SEARCH** for an answer to an issue or bug you're having. Then, only
when you have exhausted all other avenues and resources to find a solution,
should you perhaps go ahead and post a question here. Think of these sites
more as Wiki's (rather than generic Q&A channels), where ideally each
'Question' is unique enough to warrant it's inclusion in the community's
database.


All together, these tips should help you to focus on, improve, and level-up
your debugging skills. So practice, refer back here when you need to, and
remember that all programmers make mistakes ... but good programmers know how
to find and fix them, so keep these skills sharp, go forth and debug!
"""
